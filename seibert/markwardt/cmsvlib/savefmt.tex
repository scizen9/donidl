\documentclass[12pt]{article}
\setlength{\textheight}{8.5in}
\setlength{\textwidth}{6in}
\setlength{\topmargin}{-0.25in}
\setlength{\oddsidemargin}{0.25in}
\setlength{\evensidemargin}{0.25in}

% $Id: savefmt.tex,v 1.10 2002/03/26 03:41:19 craigm Exp $ 

\def\recb#1#2{\bigskip\begin{center}\par\noindent{Format: \bf #1}\qquad{\tt #2}\\[.05in]%
\begin{tabular}{|p{1.0in}|l|p{3.5in}|}\hline
{\bf Type} & {\bf Name} & {\bf Description}\\\hline}
\def\rece{\end{tabular}\end{center}\medskip}
\def\recl#1#2#3{{#2} & {#1} & {#3}\\\hline}
\def\recu#1{{#1}     & {\hfil---\hfil}  & Unknown\\\hline}
\def\tx{$\times$}

\begin{document}
\centerline{\bf\huge Unofficial Format Specification}
\centerline{\bf\huge of the IDL ``SAVE'' File}
\bigskip
\centerline{\bf Craig Markwardt\footnote{Copyright \copyright\ 2000,2001,2002 by Craig B. Markwardt}}
\smallskip
\centerline{\bf 19 Mar 2002}
\bigskip
\begin{center}
\begin{minipage}{4.5in}
\centerline{Abstract}
\bigskip
I describe the file format of IDL SAVE files, and a set of accessor
routines written in IDL which can read and write SAVE files directly.
Data and compiled functions in an IDL session can be stored on a disk
file, and restored to a new session at a later point in time.  The
data are stored using a tag-based format to encourage forward and
backward compatibility.  Programmers who wish to implement the ability
to read, write and interrogate SAVE files, and people who are just
interested in ``how it works'' should read this document.
\end{minipage}
\end{center}

\section{Introduction\label{s:intro}}

IDL\footnote{IDL is a trademark of Research Systems Incorporated
(RSI)} is the Interactive Data Language, a proprietary data processing
and visual analysis language published by Research Systems
Incorporated.  Its primary strengths are easy and efficient
manipulation of arrays, and convenient visualization tools.  One
feature of IDL is the ability to save any number of IDL ``variables''
into a file.  At any later point those variables can be restored to
memory.  This is a convenient way for a user to save all or part of
their current work session, and the session can later be resumed by
restoring the file.  The files produced by the {\tt SAVE} command, and
reconstituted by the {\tt RESTORE} command, are called ``save'' files
by RSI.  (See {\tt SAVE} and {\tt RESTORE} commands in the IDL
Reference Manual.)

The format if IDL save files is not officially documented by RSI.
They presumably do not document it because it is their ``proprietary''
information, but also because the reserve the right to change the
format at any time, and thus do not wish to be constrained by an
officially documented position.  Indeed, as I detail below, I have
found that IDL save file formats have changed slightly over time.
Still, for the most part the file format has remained remarkably
constant, and any extensions to the format that RSI has introduced in
new versions of IDL, have mostly attempted to remain compatible with
previous versions of IDL.

I have developed a library of IDL routines which is able to
interrogate, read and write IDL save files.  To be clear, this library
is not sanctioned or supported by RSI in any way.  Also, there are no
guarantees that RSI will keep the format of save files the same over
time, however my intent is to support any changes that come up.

This is my attempt to document the library functions in a rudimentary
way, and also to document the file format itself.  Hopefully this will
help other people trying to understand the format of the files,
especially programmers of other scripting languages who are trying to
construct read/write filters for IDL save files.

What follows is an overview of the IDL save format, followed by a
brief discussion of the various levels of library functions, and
finally a reference section describing in depth the format of each
record found in a save file.

\subsection{Scope\label{s::scope}}

This set of documentation, and the accompanying library routines, are
known to work with IDL save files produced by IDL version 4.0, and
versions 5.0--5.5.  They work with save files smaller than 2
gigabytes, that are uncompressed and do not contain objects.
Compressed save files will not be accessible at all, and cannot be
generated by the library.  It will be possible to access and scan save
files containing objects, but not possible to restore objects.

\subsection{Disclaimer\label{s::disclaim}}

Please note again that RSI has {\it not\/} sanctioned this
specification, and I have discovered this information purely by
examining IDL save files from known inputs on my own time.  I believe
that this information is correct, but cannot guarantee it, especially
because the file format is vulnerable to change by RSI in the future.
Use this information at your own risk.

\section{File Format Overview\label{s:overview}}

The IDL save file format is an extensible format.  By this I mean that
new record types can in principle be added without disturbing the
overall format of the file, which enhances the probability that even
an older version of IDL will be able to read the file, even if some
information is lost.\footnote{However, even RSI did not appear to
follow their own prescription when they released IDL version 5.4.  In
that version the record header (RECHEADER) format was changed
incompatibly, so that earlier versions of IDL could not read files
produced by IDL 5.4.  This situation is apparently be corrected in
the release of IDL version 5.5.}  This is possible because IDL files
are stored in a standard ``tagged record'' format.

By ``tagged record'' format, I mean that the components of an IDL save
file are each stored as a separate record type.  Each record type is
``tagged'' or marked with a code which identifies the format of the
record.  Thus, the reader of the file can decide whether it is able to
read a record based on its format code.  

At its core level, the format of an IDL save file is very simple.  It
starts with a {\it signature} block which identifies the file as an
IDL savefile, followed by a stream of records:

\recb{SAVEFMT}{(overall save file format)}
\recl{SIGNATURE}{BYTE\tx 2}{IDL SAVE file signature (=BYTE(['S','R']))}
\recl{RECFMT}{BYTE\tx 2}{IDL SAVE record format (=['00'xb, '04'xb])}
\multicolumn{3}{|c|}{Record 1}\\\hline
\multicolumn{3}{|c|}{Record 2}\\\hline
\multicolumn{3}{|c|}{$\vdots$}\\\hline
\multicolumn{3}{|c|}{Record $n$ --- END\_MARKER}\\\hline
\rece

The meaning of the above table is is that the first two bytes of the
file are a ``signature,'' followed by two bytes which identify the
record format of the file, followed by a series of standard records,
the last of which is a standard END\_MARKER record (described below).

These tables will appear throughout this document.  The first column
contains the {\it format or structure} of the element being described.
In this case ``BYTE\tx 2'' means 2 consecutive bytes.  As more complex
data structure formats are described, these may also appear in the
first column.  The second column contains the {\it name} of the
element as used in this document.  The final column contains any
descriptive comments.

It should now be clear how an IDL save file should be read.  The first
process is to open the file and read the first four bytes.  If the
first four bytes do not match the expected signature, then the file is
not in a recognized format and must be rejected.  If the match
succeeds, then the reader proceeds to read each record in turn, until
the END\_MARKER record is reached.

\section{Overview of Library Routines \label{s:library}}

This CMSAVE library allows interactive users and programmers to read,
write and interrogate IDL SAVE files.

Interactive users will probably appreciate the ability of CMSAVEDIR to
list the contents of a SAVE file without restoring it.  They will also
probably use the /APPEND keyword of CMSAVE to append additional data
to any SAVE file.

Programmers will probably use the library to write their own data, and
to read user's existing data.  The library provides higher-, middle-
and lower-level routines for reading writing and querying a SAVE
file.

For a complete documentation of the procedures, please see the
individual files.  Only an overview is given here.

\subsection{High Level Routines\label{s::highlevel}}

The high-level routines are meant to provide completely contained
procedures which interact with save files.  These routines are to be
used either on the command line, or within other programs.

CMSAVE and CMRESTORE are drop-in, but more featureful replacements to
the built-in IDL SAVE and RESTORE procedures.  CMSAVEDIR allows you to
print the contents of an existing save file without actually restoring
it, and also to interrogate the contents of the file programmatically.

Unlike the built-in versions of RESTORE, CMRESTORE and CMSAVEDIR allow
a variety of ways to access auxiliary data from a save file without
actually restoring the variables from disk.  The concept is that a
program can scan the file and decide which actions to take based on
the contents of the file, without restoring it first.  This may be
important for example, to prevent crucial variables from being
overwritten, or to compile a class before restoring an object of that
class.

For example, before restoring a file, here is a way to determine
whether it contains system variables, which may be dangerous to
restore:

\begin{verbatim}
; Extract variable names from save file
cmsavedir, 'myfile.sav', n_var=nvar, var_names=vnames, /quiet
; Find any variable names with exclamation mark '!'
sb = strpos(vnames, '!')
wh = where(sb GE 0, count)
if count GT 0 then $
  message, 'WARNING: myfile.sav contains system variables'
\end{verbatim}

It is also possible to pass data to CMSAVE and CMRESTORE using the
DATA keyword.  Data can be passed as pointers, handles or structures.
This allows for maximum flexibility and convenience for the
programmer.

\subsection{Mid Level Routines\label{s::midlev}}

The mid-level routines provide two procedures to read from and write
variables to a save file.  These routines are most useful to
programmers who wish to provide the ability to save and restore IDL
variables in a format native to IDL, with a minimum of fuss.

CMSVREAD and CMSVWRITE provide simple routines that read and write
data from a save file.  These routines are as easy to use as READF and
PRINTF.

For example, to write the three variables A B and C to a save file,
the following code is all that is necessary.

\begin{verbatim}
openw, 50, 'test.sav'       ;; Add /STREAM under VMS !
cmsvwrite, 50, a, name='a'
cmsvwrite, 50, b, name='b'
cmsvwrite, 50, c, name='c'
close, 50
\end{verbatim}

Similar code is used to read variables from a file.  However, save
files can in principle contain pointers and objects, which CMSVREAD
and CMSVWRITE cannot handle.  For those cases it is best to use either
the high- or low-level routines.  The mid-level routines are best when
it is known that a save file will have basic variables only, usually
in a predetermined order.

\subsection{Low Level Routines\label{s::lowlev}}

There are a number of low-level routines available to advanced
programmers.  CMSV\_OPEN is used to open save files for reading and
writing (the normal CLOSE is used to close the file when finished).
CMSV\_RREC and CMSV\_WREC read and write most record types from a save
file.  CMSV\_RVTYPE and CMSV\_RDATA read a variables type and data
respectively; CMSV\_WVTYPE and CMSV\_WDATA perform the equivalent
writing function.

It is best to examine the upper level routines such as CMSVREAD or
CMSAVEDIR to understand how these high level routines are to be used.

Programmers who wish to use the CMSAVE library should first include
the following code in their initialization routine.  This will
guarantee that the CMSAVE library is fully functional.
\begin{verbatim}
catch, catcherr
if catcherr EQ 0 then lib = cmsvlib(/query) else lib = 0
catch, /cancel
if lib EQ 0 then $
  message, 'ERROR: The CMSVLIB library must be in your IDL path.'
\end{verbatim}
In place of the MESSAGE call, any graceful failure action can be taken.

\section{File Format\label{s:format}}

This section and the following sections contain a detailed description
of the IDL save file format.  As described above, and IDL file
consists of a stream of tagged records:

\recb{SAVEFMT}{(overall save file format)}
\recl{SIGNATURE}{BYTE\tx 2}{IDL SAVE file signature (=BYTE(['S','R']))}
\recl{RECFMT}{BYTE\tx 2}{IDL SAVE record format (=['00'xb, '04'xb])}
\multicolumn{3}{|c|}{Record 1}\\\hline
\multicolumn{3}{|c|}{Record 2}\\\hline
\multicolumn{3}{|c|}{$\vdots$}\\\hline
\multicolumn{3}{|c|}{Record $n$ --- END\_MARKER}\\\hline
\rece

However, these records must appear in a certain order, which also
depends on which version of IDL is being used.  These records might be
described as the save file ``preamble,'' which give important metadata
about the information.  For IDL 4 this preamble consists of only one
record:

\recb{PREAMBLE4}{(preamble records for IDL 4 save files)}
\recl{TIMESTAMP}{TIMESTAMP}{Save file history information}
\rece

The first record must be of type TIMESTAMP (see below for record
types).  Beyond that, save files produced by IDL 4 do not contain heap
data.  For IDL version 5 and beyond, the preamble is extended to
include several more records after the TIMESTAMP record, which
describes the file version information, such as which version of IDL
was used to create the file:

\recb{PREAMBLE5}{(preamble records for IDL 5 save files)}
\recl{TIMESTAMP}{TIMESTAMP}{Save file history information}
\recl{VERSION}{VERSION}{Save session IDL information}
\recl{HEAP\_HEADER}{HEAP\_HEADER}{(optional) Heap index information}
\recl{PROMOTE64}{---}{(optional IDL 5.4 only) if file has ULONG64 offsets}
\rece

The HEAP\_HEADER record only appears if the save file contains heap
data (i.e., pointers).  In IDL 5.4, the PROMOTE64 record indicates the
presence of ULONG64 record offsets, which means that IDL 5.4 save
files can be larger than 2 gigabytes.

\section{Basic Record Structure\label{s:record}}

Each record has a variable length, but the beginning of the record has
a standard format up until IDL version 5.4:

\recb{RHDR}{(format of every record header in save file)}
\recl{RECTYPE}{LONG}{Numerical record format code}
\recl{NEXTREC}{LONG}{Offset to next record, relative to start of file}
\recu{LONG\tx2}
\recl{---}{---}{Remainder of record}
\rece

Thus, every record header contains at least four long words, but is
often longer, depending on the record type.  The first word contains
the format type code.  The type codes are described in more detail
below, but there is only one format per code.  The second word
contains the offset of the {\it next record} measured from the
beginning of the file.  This is how a reader walks through an IDL save
file: it must read each record header to determine the record type,
and the offset to the next record.  When the reader is finished with
the current record, it must {\it seek} (or POINT\_LUN) to the position
of the next record.

Version 5.4 of IDL has changed this record format incompatibly in some
cases.  If the PROMOTE64 record is present in the file, then the
record header format changes to the following hybrid:

\recb{RHDR64}{(format of every record header in save files after 
             PROMOTE64 record appears)}
\recl{RECTYPE}{LONG}{Numerical record format code}
\recl{NEXTREC}{ULONG64}{Offset to next record, relative to start of file}
\recu{LONG\tx2}
\rece

Note the change of LONG to ULONG64.  This change increases the length
of the record to 5 32-bit words instead of 4 32-bit words, and thus
makes all records produced by IDL 5.4 incompatible with previous
versions of IDL.  This situation is dealt with using the PROMOTE64
keyword of the save library.

{\bf NOTE:} where ``RHDR'' appears below as a data type, the actual
data type is either RHDR or RHDR64, depending on whether the PROMOTE64
record has appeared in the record stream or not.


\subsection{Record Types\label{s::rectypes}}

Here is a table containing the record type codes, the record name, and
a short description of the record contents.

\begin{tabular}{rll}
0  & {\tt START\_MARKER} & Start of SAVE file\\
1  & {\tt COMMON\_VARIABLE} & Block contains a common block definition\\
2  & {\tt VARIABLE} & Block contains variable data\\
3  & {\tt SYSTEM\_VARIABLE} & Block contains system variable data\\
6  & {\tt END\_MARKER} & End of SAVE file\\
10 & {\tt TIMESTAMP} & Block contains time stamp information\\
12 & {\tt COMPILED} & Block contains compiled procedure or function\\
13 & {\tt IDENTIFICATION} & Block contains author information\\
14 & {\tt VERSION} & Block contains IDL version information\\
15 & {\tt HEAP\_HEADER} & Block contains heap index information\\
16 & {\tt HEAP\_DATA} & Block contains heap data\\
17 & {\tt PROMOTE64} & Flags start of 64-bit record file offsets\\
\end{tabular}

All of these record types, except for VARIABLE, SYSTEM\_VARIABLE and
HEAP\_DATA, are read using the CMSV\_RREC low-level procedure.

\section{Primitives\label{s:primatives}}

Having defined the general properties of records in an IDL save file,
we will now proceed to a finer level of detail: the definition of
primitive data types within the records themselves.

The most important data types are long integers and strings, referred
to throughout this document as LONG and STRING.  These quantities are
naturally quite the same as the LONG and STRING data types found
within IDL, but because in this document they represent names of data
types as stored on disk, it is required to define their exact layout.
The library procedures CMSV\_RRAW and CMSV\_WRAW are used to read and
write these types of data values.

Please NOTE: the formats of quantities stored in IDL {\it variables}
can be somewhat different than these raw quantities.  This section
only refers to how the fundamental units of the file are formatted.
See Sec.~\ref{s:dvalue} for the format of IDL variable data.

The integer types are stored in IEEE format, and are automatically
converted by the CMSV\_RRAW and CMSV\_WRAW procedures.  Note that {\it
every\/} integer value is encoded according the following table,
including those within record headers, and stored in string length
values.

\recb{INTEGER\_TYPES}{(list of integer data types)}
\recl{BYTE}{BYTE}{Single native byte}
\recl{LONG}{BYTE\tx4}{32-bit signed word, IEEE format}
\recl{ULONG64}{BYTE\tx8}{64-bit unsigned word, IEEE format}
\rece

The string type is another fundamental type.  A string contains any
variable-length stream of bytes.  The first quantity is a LONG integer
which describes the length of the string in bytes, followed by the
bytes themselves.  

\recb{STRING}{(format of string data type)}
\recl{LENGTH}{LONG}{Length of the string in bytes}
\recl{CHARS}{BYTE\tx LENGTH}{Characters of string, expressed as bytes.
If the string is empty, i.e., if LENGTH is zero, then no CHARS are
present.  There is no zero termination.}
\recl{PAD}{BYTE\tx N}{Padding bytes, to align stream to next 32-bit
boundary.  If the stream is already on a 32-bit boundary, or if LENGTH
is zero, then no PAD bytes appear.}
\rece

Thus, an empty (zero-length) string would simply be composed of a
single LONG integer with the value of zero.

\section{Record Descriptions\label{s:recdesc}}

The following sections describe the actual formats of the records
which have been outlined above.  The ``preamble'' records (records
which contain metadata) appear first, followed by the ``content''
records (which contain user data), and finally the end-of-file record
is described.

\subsection{Preamble Records\label{s::preamble}}

Preamble records must appear first in the file and typically describe
the properties of the {\it file}, rather than the data itself.  This
metadata includes when the file was saved and by whom, and which
version of IDL wrote it.  By observation there appears to be an
established order for these records to appear in a file, but it is not
known whether this ordering is required or merely the default.  The
order appears to be:

\begin{enumerate}
\item TIMESTAMP --- time and user information
\item VERSION --- information about the version of IDL 
\item PROMOTE64 --- (optional) signals presence of large data
\end{enumerate}

\recb{TIMESTAMP (10)}{(timestamp and user information)}
\recl{HDR}{RHDR}{Block header record}
\recl{---}{LONG\tx 256}{Unknown ( = LONARR(256))}
\recl{DATE}{STRING}{Date session was saved, as a string.}
\recl{USER}{STRING}{User name of saved session.}
\recl{HOST}{STRING}{Host name of saved session.} 
\rece

NOTES: The TIMESTAMP record always appears to come first.  Depending
on the host operating system, the ``user'' and ``host'' fields may be
empty or contain unreliable data.  The format of the DATE field
appears to be ``WWW MMM DD hh:mm:ss YYYY'' where the WWW is an
abbreviation of the name of the day of the week, MMM is an
abbreviation of the month name, DD is the day of the month, YYYY is
the calendar year, and ``hh:mm:ss'' is the 24-hour time.


\recb{VERSION (14)}{(version information)}
\recl{HDR}{RHDR}{Block header record}
\recl{FORMAT}{LONG}{Save file format version number (= 5?)}
\recl{ARCH}{STRING}{Architecture of saved session (= !VERSION.ARCH)}
\recl{OS}{STRING}{OS of saved session (= !VERSION.OS)}
\recl{RELEASE}{STRING}{IDL version of saved session ( = !VERSION.RELEASE)}
\rece

NOTES: The VERSION type can be used to determine which version of
IDL, and which OS was used to write a particular save file.  It does
not appear in files generated by IDL 4.  I do not believe I have seen
any records where the FORMAT value was different than 5.

\recb{PROMOTE64 (17)}{(signals start of RHDR64 record headers)}
\recl{HDR}{RHDR}{Block header record}
\rece

NOTES: Any records which appear {\it after\/} this record will have
RHDR64 record headers in place of RHDR records.  This record is not
mandatory, and only appears in files generated by IDL version 5.4 or
later.

\recb{IDENTIFICATION (13)}{(provides author information)}
\recl{AUTHOR}{STRING}{Author of save file}
\recl{TITLE}{STRING}{Title of the save file}
\recl{IDCODE}{STRING}{Other author information}
\rece

NOTES: This record is optional, and appears to provide more definitive
information about who saved the IDL file.  [ This may be more useful
for SAVE files which contain compiled procedures and functions. ]
There appears to be no direct way for users to specify this
information from the built-in IDL SAVE command, but there does seem to
be some connection to the EMBEDDED keyword to SAVE, and the creation
of embedded-license save files.

\recb{HEAP\_HEADER (15)}{(heap data table of contents)}
\recl{NVALUES}{LONG}{Number of heap values in SAVE file}
\recl{INDICES}{LONG\tx\ NVALUES}{Indices of heap values}
\rece

NOTES: This record appears only if the file contains heap data, which
is data {\it pointed to\/} by IDL pointers.  Pointers are available
only in IDL version 5.0 or later.  The HEAP\_HEADER record is merely a
table of contents record which describes how many heap values there
are, and lists there numerical index values.  The use of the heap
index values is described later in this document.


\subsection{Content Records\label{s::content}}

This section describes data which contain actual content, however,
they contain subtypes which will require further elaboration in later
sections.

\recb{COMMONBLOCK (1)}{(declaration of common block and variables)}
\recl{HDR}{RHDR}{Block header record}
\recl{NVARS}{LONG}{Number of common block variables}
\recl{NAME}{STRING}{Name of common block}
\recl{VARNAMES}{STRING \tx NVARS}{Names of common block variables}
\rece

NOTES: This record describes the existence, but not the values of, any
common block variables.  This is equivalent to the declarative COMMON
statement in an IDL procedure.  The names of the common variables are
established, but the values must be defined by another separate record
which appears later in the file.


\recb{VARIABLE}{(definition of standard IDL variable)}
\recl{HDR}{RHDR}{Block header record}
\recl{VARNAME}{STRING}{Name of IDL variable (upper case ASCII)}
\recl{TYPEDESC}{TYPEDESC}{Variable type descriptor}
\recl{VARSTART}{LONG}{Indicates start of data (= 7)}
\recl{VARDATA}{VARDATA}{Variable data}
\rece

\recb{SYSTEM\_VARIABLE}{(definition of IDL system variable)}
\recl{HDR}{RHDR}{Block header record}
\recl{VARNAME}{STRING}{Name of IDL system variable (upper case ASCII,
                       begins with '!')}
\recl{TYPEDESC}{TYPEDESC}{Variable type descriptor}
\recl{VARSTART}{LONG}{Indicates start of data (= 7)}
\recl{VARDATA}{VARDATA}{Variable data}
\rece

NOTES: The formats of standard IDL variables and system variables are
the same.  The only difference is the VARFLAGS flag byte within the
TYPEDESC descriptor.  The definitions of TYPEDESC and VARDATA are
presented in sections \ref{s:typeform} and \ref{s:dvalue}.  The
TYPEDESC segment defines the type of the data, and is read and written
by CMSV\_RVTYPE and CMSV\_WVTYPE.  The VARDATA segment actually
contains the data, and is read and written by CMSV\_RDATA and
CMSV\_WDATA.

For scalars TYPEDESC is simply the IDL type number, but for arrays and
structures the TYPEDESC descriptor can be much more complicated.
Because the TYPEDESC descriptor can have a variable size, depending on
the complexity of the type being described, it is not possible to
parse the data segment of the record without first parsing the type
descriptor.

\recb{HEAP\_DATA}{(type and data for IDL heap variable)}
\recl{HDR}{RHDR}{Block header record}
\recl{HEAP\_INDEX}{LONG}{The heap index of this particular variable.
            This index refers to the table of contents found in the
            HEAP\_HEADER record.}
\recl{---}{LONG}{Unknown ('02'XL or '12'XL)}
\recl{TYPEDESC}{TYPEDESC}{Heap variable type descriptor}
\recl{VARSTART}{LONG}{Indicates start of data (= 7)}
\recl{VARDATA}{VARDATA}{Heap variable data}
\rece

NOTES: A heap variable has the same format as an IDL standard or
system variable, except that, instead of a STRING variable which
provides the name of the variable, an integer number is used to
identify which variable it is in the heap table of contents.

\subsection{Compiled Procedures and Functions\label{s::compiled}}

It is outside of the scope of this document to describe the records
which contain compiled procedures or functions.  The beginning of the
record has the following format:

\recb{COMPILED}{(compiled procedure or function)}
\recl{HDR}{RHDR}{Block header record}
\recl{PRONAME}{STRING}{Name of procedure or function (upper case ASCII)}
\recl{LENGTH}{LONG}{Length of procedure (unknown units?)}
\recl{N\_VARS}{LONG}{Number of variables used in procedure}
\recl{N\_ARGS}{LONG}{Total number of parameters and keywords}
\recl{PROFLAGS}{LONG}{Bit flags for procedure type, OR'd as follows:
\begin{tabular}{ll}
{\tt '01'x} & Record is a function; else, procedure \\
{\tt '02'x} & Procedure accepts keywords \\
{\tt '08'x} & Uses \_EXTRA keyword parameter \\
{\tt '10'x} & Unknown? (defined for every procedure) \\
{\tt '20'x} & Record is a method \\
{\tt '40'x} & Is a lifecycle method \\
\end{tabular}}
\multicolumn{3}{|c|}{$\vdots$}\\
\multicolumn{3}{|c|}{Undefined}\\
\multicolumn{3}{|c|}{$\vdots$}\\\hline
\rece

NOTES: The default is for all flags (except {\tt '10'x}) to be zero,
i.e., procedure which does not accept keywords and is not a method.
Method-type procedures and functions apply to objects, are only
meaningful in IDL 5.0 or greater.  A ``lifecycle method'' is one
which is used to create or destroy an object.

\subsection{Concluding Record\label{s::concl}}

The final record in an IDL save file is the END\_MARKER record.  It is
empty, other than the record header that every record contains.  I
currently believe that any data following this record is ignored by
IDL.

\recb{END\_MARKER (6)}{(signals end of file)}
\recl{HDR}{RHDR}{Block header record}
\rece

NOTES: Applications can use the presence of this record to terminate
processing.


\section{Data Type Descriptor Formats\label{s:typeform}}

This section describes the format of the TYPEDESC segment, which
appears in records of type VARIABLE, SYSTEM\_VARIABLE and HEAP\_DATA.
All of these record types come in three parts.  First, the {\it
name\/} or {\it index number\/} of the variable appears, which
describes its identity; second, the {\it type} of the variable is
described, such as array dimensions, data type, and whether it is a
structure; finally, the data itself appears.  This section describes
how the data types are stored on disk.

The data types can be divided into several possible cases:
\begin{enumerate}
\item Scalar numbers, strings or pointers.
\item Array numbers, strings or pointers.
\item Structures.
\item Objects.
\end{enumerate}

By convention, structures are always arrays, so the data type
descriptors for arrays and structures naturally overlap.  While
objects can be stored in IDL save files, the CMSV library does not
support them.

\subsection{Simple Scalar Quantities\label{s::scalar}}

The type descriptor for ``simple'' scalar quantities has the following
format.  Here ``simple'' means integers, floating point values (real
and complex), strings, and pointers.

\recb{TYPEDESC\_SCALAR}{(type descriptor for simple scalars)}
\recl{TYPECODE}{LONG}{IDL variable type code}
\recl{VARFLAGS}{LONG}{Bit flags for a type descriptor, OR'd as follows:
\begin{tabular}{ll}
{\tt '02'x } & System variable \\
{\tt '04'x } & Array (UNSET for scalar)\\
{\tt '10'x } & Unknown? \\
{\tt '20'x } & Structure (UNSET for scalar)\\
\end{tabular}}
\rece

NOTES: All of the type descriptor formats begin physically with a
TYPECODE and VARFLAGS field.  In the case of scalars, those are the
only two fields in the descriptor.  All scalars have a VARFLAGS value
of zero or one, indicating either a system variable or not, but {\it
not \/} an array or structure.

The IDL TYPECODE is the data type that is used throughout IDL, and by
the SIZE function, to describe the basic type of a quantity.  The
values are contained in the following table:

\begin{center}
\centerline{\bf IDL data type codes}
\begin{tabular}{|r|l|}
\hline
 0 & Undefined (not allowed)\\\hline
 1 & Byte \\\hline
 2 & 16-bit Integer \\\hline
 3 & 32-bit Long Integer \\\hline
 4 & 32-bit Floating Point Number \\\hline
 5 & 64-bit Floating Point Number \\\hline
 6 & Complex Floating Point Number (32-bits each) \\\hline
 7 & String \\\hline
 8 & Structure (never a scalar) \\\hline
 9 & Complex Floating Point Number (64-bits each) \\\hline
10 & Heap Pointer \\\hline
11 & Object Reference (not supported by CMSVLIB) \\\hline
12 & 16-bit Unsigned Integer \\\hline
13 & 32-bit Unsigned Integer \\\hline
14 & 64-bit Integer \\\hline
15 & 64-bit Unsigned Integer \\\hline
\end{tabular}
\end{center}

The next sections describe the enhancements that are in place for
arrays and structures.

\subsection{Arrays\label{s::arrays}}

Arrays are an extension of simple data types.  In addition to the type
code and VARFLAGS field, there is an additional segment called
ARRAY\_DESC, which describes the structure of the array:

\recb{TYPEDESC\_ARRAY}{(type descriptor for arrays)}
\recl{TYPECODE}{LONG}{IDL variable type code}
\recl{VARFLAGS}{LONG}{Bit flags for a type descriptor, OR'd as follows:
\begin{tabular}{ll}
{\tt '02'x } & System variable \\
{\tt '04'x } & Array \\
{\tt '10'x } & Unknown? \\
{\tt '20'x } & Structure (UNSET for simple array)\\
\end{tabular}}
\recl{---}{ARRAY\_DESC}{Array descriptor segment}
\rece

An array descriptor structure is a fixed-length segment describing the
dimensions of the array.

\recb{ARRAY\_DESC}{(array descriptor)}
\recl{ARRSTART}{LONG}{Indicates start of array descriptor (= 8)}
\recl{---}{LONG}{Unknown (= 2)}
\recl{NBYTES}{LONG}{Number of bytes in array}
\recl{NELEMENTS}{LONG}{Number of elements in array}
\recl{NDIMS}{LONG}{Number of dimensions in array}
\recl{---}{LONG\tx2}{Unknown (= [0,0])}
\recl{NMAX}{LONG}{Number of stored dimensions (always 8?)}
\recl{DIMS}{LONG\tx NMAX}{Dimensions of array, padded with 1s to NMAX}
\rece

NOTES: The ARRAY\_DESC descriptor indicates the size of the array in a
number of different manners.  The total number of elements is given by
the NELEMENTS field.  The number of dimensions in the array is given
by NDIMS.  Even if NDIMS is less than 8, the array descriptor always
appears to contain NMAX (=8) stored dimensions.  The ``unused''
dimensions are padded with values of 1.

\subsection{Structures\label{s::struct}}

Structures are the most complex form of data stored in an IDL save
file, because they can represent any combination of scalars, arrays,
and structures.  Thus, the format of the structure descriptor must be
general enough to store any kind of data.

\recb{TYPEDESC\_STRUCT}{(type descriptor for arrays)}
\recl{TYPECODE}{LONG}{IDL variable type code}
\recl{VARFLAGS}{LONG}{Bit flags for a type descriptor, OR'd as follows:
\begin{tabular}{ll}
{\tt '02'x } & System variable \\
{\tt '04'x } & Array \\
{\tt '10'x } & Unknown? \\
{\tt '20'x } & Structure \\
\end{tabular}}
\recl{---}{ARRAY\_DESC}{Array descriptor segment}
\recl{---}{STRUCT\_DESC}{Structure descriptor segment}
\rece

The array descriptor is described in the previous section.  All
structures are also arrays, and hence every structure type description
will have both an ARRAY\_DESC and STRUCT\_DESC segment.  Even
``scalar'' structures are considered to be an array of length and
dimension equal to 1.  The structure descriptor is defined here:

\recb{STRUCT\_DESC}{(variable structure descriptor)}
\recl{STRUCTSTART}{LONG}{Indicates start of struct descriptor (= 9)}
\recl{NAME}{STRING}{Name of structure (empty string indicates 
                    anonymous structure).}
\recl{PREDEF}{LONG}{Predefined structure.  A value of 1 indicates that the
                    structure was previously defined in this save file.  A
                    value of 0 indicates this is a fresh definition.}
\recl{NTAGS}{LONG}{Number of tags in structure.}
\recl{NBYTES}{LONG}{Number of bytes in structure, using IDL notation.
                    Actual number of bytes may vary from architecture
                    to architecture.  If PREDEF EQ 1 then this is the
                    last field that appears, and the previously
                    defined structure is used.  If PREDEF EQ 0 then
                    the following fields appear.}  
\recl{TAGTABLE}{TAG\_DESC \tx NTAGS}{Table of tag descriptors, which 
                describe the types of each tag.}
\recl{TAGNAMES}{STRING \tx NTAGS}{Table of names for tags.}
\recl{ARRTABLE}{ARRDESC \tx NARRAYS}{If any tag is an array type, then its
                    dimensions are described by the following ARRDESC 
                    entries.  The entries appear in the order they are in the
                    structure; NARRAYS is determined from the values in
                    TAGTABLE.}
\recl{STRUCTTABLE}{STRUCTDESC \tx NSTRUCTS}{If any tag is a structure type, 
                    then its tags are described by the following STRUCTDESC
                    entries.  The entries appear in the order they are in the
                    structure; NSTRUCTS is determined from the values in
                    TAGTABLE.}
\rece

NOTES: The length of this segment depends on whether it is {\it
definitional\/} or {\it referential}.  A definitional structure
descriptor describes a structure the first time it appears in the data
stream, and in that case the full descriptor is used.  After the first
time the structure has been defined, other appearances of the same
structure may {\it refer\/} to the first definition by setting PREDEF
to a value of one.

The end of the structure descriptor can itself contain one or more
array or structure descriptors.  Any array descriptors first, in the
order that they appear in the structure; followed by any structure
descriptors, in the order they appear in enclosing the structure.

The decision of whether a tag is a structure, array or scalar is
described by the TAG\_DESC


\recb{TAG\_DESC}{Descriptor of a structure tag}
\recl{OFFSET}{LONG}{Figurative ``offset'' of tag from start of struct.
                    This number is typically meaningless since the true 
                    offset is architecture dependent.}
\recl{TYPECODE}{LONG}{IDL variable type of tag value.}
\recl{TAGFLAGS}{LONG}{Bit flags for variable type, OR'd together:
\begin{tabular}{ll}
{\tt '20'x} & Tag is a structure\\
{\tt '10'x} & Tag may be an array (?)\\
{\tt '04'x} & Tag is an array\\
\end{tabular}}
\rece

It is not clear what the {\tt '10'x} bit flag of TAGFLAGS means.  As
noted in the table, the ``offset'' value is usually not meaningful
because it depends on a platform-dependent layout of structures.

\section{Data Value Formats\label{s:dvalue}}

For records of type VARIABLE, SYSTEM\_VARIABLE and HEAP\_DATA, the
final segment of data in the record is the data itself (VARDATA).  For
all of these record types, the data format is the same.

For ``simple'' data types (as defined above), and arrays of simple
data types, the data {\it usually\/} appears in its native format.
However, some data types are translated into a slightly different form
for the SAVE format.  The following table specifies how this
transformation is performed.

\begin{center}
\begin{tabular}{ll}
\hline
{\bf IDL Type} & {\bf Storage Type \& Format} \\
\hline
BYTE & BYTE \\
Signed or Unsigned INT (16-bit) & (U)LONG (32-bit) IEEE \\
Signed or Unsigned INT (32-bit) & (U)LONG (32-bit) IEEE \\
Signed or Unsigned INT (64-bit) & (U)LONG64 (64-bit) IEEE \\
FLOAT (32-bit) & FLOAT (32-bit) IEEE \\
DOUBLE (64-bit) & DOUBLE (64-bit) IEEE \\
COMPLEX (32-bit) & 2\tx FLOAT (32-bit) IEEE \\
DCOMPLEX (64-bit) & 2\tx DOUBLE (64-bit) IEEE \\
STRING & STRING\_DATA (see below) \\
POINTER & LONG (32-bit) IEEE (see below) \\
\hline
\end{tabular}
\end{center}

The alignment of the start of all types is on a 32-bit boundary.
Array storage formats are packed as closely as possible, i.e., byte
arrays are stored as packed bytes.  The ends of byte scalars and byte
arrays are padded out to the next 32-bit boundary.

String arrays are also packed together as tightly as possible.  Thus,
an array of strings will have a variable size depending on the sizes
of the strings in the array.  [ Arrays of the integer types have a
perfectly predictable size. ]  However, the format of stored strings
is slightly different from the STRING type defined above.  Here the
format type STRING\_DATA is defined:

\recb{STRING\_DATA}{(format of strings within variable data)}
\recl{LENGTH}{LONG\tx 2}{Length of the string in bytes (length repeated)}
\recl{CHARS}{BYTE\tx\ LENGTH}{Characters of string, expressed as bytes.
If the string is empty, i.e., if LENGTH is zero, then no CHARS are
present.  There is no zero termination.}
\recl{PAD}{BYTE\tx N}{Padding bytes, to align stream to next 32-bit
boundary.  If the stream is already on a 32-bit boundary, or if LENGTH
is zero, then no PAD bytes appear.}
\rece

The difference here is that the LENGTH field is repeated twice rather
than appearing only once for the STRING data type.

Pointers are a special case.  Pointers are stored as long integers.
The integer is the same heap index value that appears in the HEAP\_HEADER
table of contents record, and the HEAP\_DATA record.  A pointer value
of 3, for example, refers to the heap variable whose index value is
also 3.  Note that it is possible for more than one pointer to refer
to the same heap variable.

Structures are obviously composed of more simple data types and
(possibly) other structures.  The individual components of a structure
are stored, in order, packed on 32-bit boundaries.

\section{Pointers and Heap Values\label{s:pointer}}

Pointer data stored in IDL SAVE files are particularly difficult
to manage, because the actual heap variables are stored in
separate records which {\it precede\/} the record of interest.  Thus, if
your application requires the reading of pointer data, you must
perform special processing in your own code in order to support
it.  In essence, you must maintain an inventory of heap variables
as they are encountered in the file.

If these procedures are not followed then pointer data will not be
read, and a LONG integer value appears in the pointers' places.
Under IDL 4, pointer data can never be read.

This is accomplished by placing some additional logic in your file
processing loop.  There are four separate components to this: (1)
loop initialization; (2) reading a HEAP\_INDEX record; (3) parsing
a HEAP\_DATA record; and (4) passing extra arguments to CMSV\_RDATA.
The additional state information is maintained in two variables
named PTR\_INDEX, which keeps track of the heap variable numbers,
and PTR\_OFFSETS, which stores the file location of each variable.

\begin{enumerate}
\item Loop initialization: is quite simple, use the following code:
\begin{verbatim}
    ptr_index   = [0L]
    ptr_offsets = [0L]
    ptr_data    = [ptr_new()]
\end{verbatim}

\item Reading HEAP\_INDEX, which is an array of values indicating
    the heap variable numbers of each heap variables.  These
    values are stored in PTR\_INDEX:

\begin{verbatim}
       CMSV_RHEAP, block, pointer, index, unit=unit
       ptr_index   = [ptr_index, index]
       ptr_offsets = [ptr_offsets, lonarr(n_elements(index))]
       ptr_data    = [ptr_data, ptrarr(n_elements(index))]
\end{verbatim}

\item Parse the HEAP\_DATA record.  Here were are interested in the
    heap variable number, and the file offset.

\begin{verbatim}    
    opointer = pointer
    CMSV_RVTYPE, block, pointer, vindex, /heap, unit=unit
    
    vindex = floor(vindex(0))
    wh = where(ptr_index EQ vindex)
    ptr_offsets(wh(0)) = offset + opointer
\end{verbatim}

    Keep in mind that the file offset is OFFSET+POINTER.

\item Pass extra parameters to CMSV\_RDATA.  The user simply passes
    these extra variables to the CMSV\_RDATA procedure, which
    automatically recognizes heap data and reads it from the
    appropriate location.

\begin{verbatim}
    CMSV_RVTYPE, block, pointer, name, size, unit=unit, template=tp
    CMSV_RDATA, block, pointer, size, data, template=tp, $
      unit=unit, ptr_offsets=ptr_offsets, $
      ptr_index=ptr_index, ptr_data=ptr_data
\end{verbatim}
\end{enumerate}

If this technique is used properly, only those heap variables
which are needed are read.  Thus, there are never any lost or
dangling pointers.  Since each bit of heap data is stored in a
variable returned to the user, it is not necessary to
\verb|PTR_FREE(ptr_data)|; in fact, doing so would corrupt the input
data.


\end{document}
